# Verilog 基础语法

## 一    实验目的

1. 理解 Verilog 代码的意义
2. 熟悉理解 Verilog 代码的基础语法
3. 掌握基础的 Verilog 代码应用

## 二    实验环境

1. EDA 工具： Vivado（可以选择使用 vscode 帮助编辑 verilog ）
2. SWORD 开发板
3. 操作系统： Windows 10+

## 三    实验原理

### 1. 什么是Verilog HDL

Verilog HDL 是一种硬件描述语言，以文本形式来描述数字系统硬件的结构和行为的语言，用它可以表示逻辑电路图、逻辑表达式，还可以表示数字逻辑系统所完成的逻辑功能。设计者可以用它进行各种级别的逻辑设计，可用它进行**仿真验证、时序分析、逻辑综合**，它也是目前应用最广泛的一种硬件描述语言。

### 2. Verilog有什么意义

在之前的几个实验，大家可以发现，我们都是通过 Logisim Evolution 作图来进行电路设计，这也是最直接的一种逻辑设计方式，我们直接将不同的门电路通过线路来连接，并实现不同的逻辑功能。但是在设计完电路图之后，大家会发现我们设计的电路最后都转化为文本代码的形式才能在 vivado 上使用（Lab4 四-1），这里实际上就是 Logisim Evolution 软件将我们所作的电路图，转化为了 Verilog 代码，同时，Verilog 代码也可以转化为电路图。

而且大家可以想象一下，我们当前设计的仅仅是最简单的逻辑电路，我们可以通过一个个画图来实现，但是如果我们需要设计一个简单的计算器，或者设计一个小游戏，甚至一个 CPU ，那整体的工作量将是巨大的，我们不可能通过电路图的设计来一步步完成，因此我们需要一个更快、更有效率的硬件设计方法来实现。

同时，我们还发现在完成电路后，我们可以通过一段 Verilog 代码来进行模拟（Lab4 四-2），我们可以用 Verilog 代码模拟不同的输入，然后观察整个电路输出，从而判断我们的电路逻辑是否有错。

最后，我们需要增加引脚文件，对整个电路进行综合，就可以将电路上板验证。

刚刚我们提到的三个步骤，其实就对应了它的三个作用，**仿真验证、时序分析、逻辑综合**，我们在后面的实验中，尤其是最后的大程中，我们将大量的用到 Verilog代码 。不仅在数字逻辑设计这门课，包括后续的计算机组成、计算机系统概论中，我们也基本通过Verilog语言来进行硬件设计编程。因此，在后面的实验中，除了必要的需要设计图来理解电路外，我们都将要求使用Verilog代码来进行实验。

### 3.Verilog代码的设计方法

Verilog 代码与同学们之前学习的 C 语言有很多相似之处，比如自顶向下设计思想、模块化编程、循环语句、条件语句、多路分支语句等，但是又与 C 语言大不相同，因为这是一个**硬件描述语言**，最后所有代码都将转化为各种门与电路的相连，无论何时同学们都应记住这一点，将 Verilog 代码当作真实的硬件电路去设计，而不是将 C 语言编程的那一套照搬到 Verilog 编程中去。

#### 自顶向下设计思想

![自顶向下设计思想示意图](img/lab6/2.jpg)

在 Verilog 代码设计中，我们要有自顶向下设计思想的思路，这里也有模块化思想在里面。大家在最开始的几个 lab 中设计了最基础的逻辑门，比如与门、非门等，但是在 lab4 的设计中，我们发现可以直接调用这些门，而不是将其中的细节再一一展示。这里我们就可以理解为，lab4 的工程是顶层模块，子模块就是一个个门。

下面我们再举一个例子，比方说我需要设计一个可以处理加减乘除的计算器（这个其实就是我们后续的实验 ALU 器件），那这个计算器就是我的顶层逻辑，下面我需要开始思考，如果直接设计这个计算器比较困难，如果有一个模块，他可以处理加减乘除中的一个计算就可以了（功能更简单的子模块），那我就可以用这四个小模块来组成计算器这个顶层模块。下面我们再分别考虑仅能处理单一加减乘除的子模块，我们就可以用不同的门来实现，这个门就是子模块的叶单元。

这样，我们就从需要设计一个大的多种功能的计算器，变成了设计四个小的单一功能的子模块，这样还有一个好处就是顶层模块不会因为内容太多太乱而影响我的 debug ，子模块也相对简单独立，如果有其他需要加法器或者减法器的需求时，我们也可以直接调用子模块而不必重新设计，增加了复用性。

#### 行为级描述

我们使用 Verilog 代码编程的思路不同于直接作图。

直接作图是结构级描述，而 Verilog 代码编程则是 行为级描述。

大家回顾我们在作图的时候，是不是在对一个电路的内部各类门器件等的结构进行设计，侧重对模块内部结构实现的具体描述。
譬如我需要摆几个与门，几个或门，如何连接。

但是在 Verilog 编程时，我们则是侧重对模块行为功能的抽象描述。譬如这里需要进行多路选择我就用case语句，这里需要条件判断就用if语句等等。

下面我们举一个很简单的例子来说明这件事，现在有三个位宽为1的输入A、B、C，一个位宽为1的输出S。

我们希望实现当 C = 0 时，S 输出 A 的值；当 C = 1 时，S 输出 B 的值。

这是一个很简单的二路选择器，如果我们采用作图来实现，则考虑如何利用与非门来实现这个结果，规划结构，最后作图如下：

![二路选择器](img/lab6/3.jpg)

我们会发现我们思考的方式是在构建这个结构，即用与非门如何实现这个功能，在构建门器件与电路的结构。

如果用Verilog编程的角度来思考，我们则会考虑输入的 A、B、C 三个变量与输出的 S 之间存在一个条件选择关系，因此我们可以使用if条件语句或者条件操作符来实现。

```
module mux2to1(
    input A,
    input B,
    input C,
    output S
)

    assign S = C ? B : A;
```


#### Verilog代码的设计流程

这部分我们在实验中一般不会设计，感兴趣的同学可以通过[这里](https://www.runoob.com/w3cnote/verilog-design-method.html "设计流程")自行查看。

### 4. Verilog代码的基础知识

#### 语句、注释与格式

Verilog 中每个语句需要以";"结尾，空白符（换行、制表、空格）都没有实际的意义，在编译阶段可忽略。

同时 Verilog 代码格式自由，可以在一行内编写，也可以在多行内编写。这里推荐大家在写 Verilog 代码时有良好的排版习惯，方便自己对代码的理解和后期的 debug 。

同时在Verilog中用"//"进行单行注释，用"/* ... */"进行多行注释

```
// 不好的编程习惯
wire [1:0]  results ;assign results = (a == 1'b0) ? 2'b01 ： (b==1'b0) ? 2'b10 ： 2'b11 ;

// 良好的编程习惯
wire [1:0]  results ;
assign      results = (a == 1'b0) ? 2'b01 ：
                      (b == 1'b0) ? 2'b10 ：
                      2'b11 ;
```

#### 标识符与关键字

标识符可以是任意一组字母、数字、$ 符号和 _(下划线)符号的合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元符开始，标识符也区分大小写。
关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。

```
reg [3:0] counter ; //reg 为关键字， counter 为标识符
input clk; //input 为关键字，clk 为标识符
input CLK; //CLK 与 clk是 2 个不同的标识符
```

#### 表达式表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用

表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。

```
// 下面的两个表达式意义相同
( 2'b11 - 2'b10 ) // 由操作数 2‘b11和2’b10 以及操作符 "-" 组成
2‘b01             // 由操作数 2’b01组成
```

**操作数**

操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。
操作数可以为常数，整数，实数，线网，寄存器，时间，位选，域选，存储器及函数调用等。

**操作符**

Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。

由于我们还没有介绍数值表达，因此在这里讲操作符较为突兀难以理解，我们将其转至数值表示之后。

#### 数值表示

在 Verilog 中，我们主要会用到两种数值表示：电平逻辑和整数数值表示

Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑：

0：逻辑 0 或 "假"

1：逻辑 1 或 "真"

x 或 X：未知

z 或 Z：高阻

在数字声明时，有十进制('d 或 'D)，十六进制('h 或 'H)，二进制（'b 或 'B），八进制（'o 或 'O）四种合法的基数格式，通常来说我们在表达数字时，需要写明数字的位宽和使用的基数。

为了增强可读性，可以在数字声明内加入"_"，并不影响实际表达。

```
// 位宽为4 使用基数为二进制 四位上全为1的整数
4‘b1111

// 位宽为32 使用基数为十六进制 
32‘h1234_ABCD
```

**特别注意，这里的位宽指的是声明数字所占的位数，而不是指转化后的数字位数，比如上面的32‘h1234_ABCD，这个后面的十六进制表达进需要8位，每一位代表一个16进制数，需要4位宽来存储，因此实际这个数需要8*4=32位，因此写明的是32位宽**

此外，Verilog中还有负数、实数、字符串的数据类型表示，但是在后续实验中很少用到，因此仅简单提及。

```
// 负数表示
-6'd15  

// 实数表示 十进制
30.123
// 实数表示 科学计数法
1_0001e4      //大小为100010000
1E-3          //大小为0.001

// 字符串表示
reg [0: 14*8-1]       str ;
initial begin
    str = "www.runoob.com";
end  
```

#### 数据类型

刚刚我们介绍了数值表示，现在我们要介绍 Verilog 中的数据类型。

首先我们要再回顾一件事，Verilog HDL 是个一种硬件描述语言，我们所写的Verilog代码实际上都要转化为真实的电路，无论何时大家都要牢记这点。

然后我们带着这个前提，再来去看Verilog的数据类型，其实就很好理解了。

在Verilog中，最常用的 2 种数据类型就是线网（wire）与寄存器（reg），其余类型可以理解为这两种数据类型的扩展或辅助。


**1.线网**

wire 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 "Z"。

在 Logisim Evolution 中，我们会通过线路将不同的器件连在一起，这个其实就是创建了一个线网的对象，然后将线网连在两个器件的接头上。同时，在写Verilog代码时，我们也要有意识，创建了一个wire的类型，其实上就是给一根线网命名，下面你可以将它的两端分别接上不同的接口（一个驱动或输出的接口，一个另一个接受的接口）。


```
wire   flag1, flag2 ;
```

此外，对 wire 的赋值不可以在 always / initial 以内，只能在 always / initial 之外（在后面看到 always / initial 的部分时可以思考为什么）
对wire赋值意味着什么？

对wire赋值意味着将线网接地或者接高电平。

**2.寄存器**

寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写。

在后续的实验中，我们也会自己动手写不同的锁存器，如 SR 锁存器、D 锁存器等，大家做到后面的实验后可以更好的理解寄存器的含义。
但是现在大家在写的时候就要有意识，创建的 reg 类型并不是像C语言一样创建了一个虚拟的内存地址，而是创建了一个真实的模组，对 reg 的改变其实就是通过对模组的不同输入实现，对 reg 的读取其实就是将模组的输出端介入。

**3.向量**

在实际的设计中，我们很多时候需要存储或者传输的数据位宽不为 1，虽然我们可以通过创建多个 wire 或者 reg 来实现，但是这样既不利于整个工程的管理，也会带来很大的工作量，因此在 Verilog 中有向量的概念，可以定义位宽大于1的 wire 或者 reg 。

我们可以发现，在 Verilog 代码中，一个线网存在其实就是为其命名，创建这个 wire 数据类型，以便于后面我们再对其进行各类操作，寄存器也是如此。
我们可以将向量理解为同时创建多个 wire 或者 reg ，并命名为同一个名字，同时编号区分。
譬如位宽为4的线网 "wire [3:0] line"，你可以理解为一捆共四根线网被绑定在一起，且有序号区分，你可以通过 "line[n]\(n=0,1,2,3\)" 来定位到不同的线网。

```
reg [3:0]      counter ;    //声明4bit位宽的寄存器counter
wire [32-1:0]  gpio_data;   //声明32bit位宽的线型变量gpio_data
wire [8:2]     addr ;       //声明7bit位宽的线型变量addr，位宽范围为8:2
reg [0:31]     data ;       //声明32bit位宽的寄存器变量data, 最高有效位为0
```

此外，我们还可以用向量形式制定一根或几根线网/寄存器来作其他逻辑使用。如：

```
reg [3:0] data = 4'b1011;           // data[3:0] = 4'b1011;
reg [3:0] data_low = data[0:3] ;    // data_low[3:0] = 4'b1101


reg addr[8:0] = 9'h10F;             // addr[8:0] = 9'b1_0000_1111
addr_temp[3:2] = addr[8:7] + 1'b1 ; // addr_temp[3:2] = 2'b11
                   2'b10  
```

此外，Verillog 还支持指定 bit 位后固定位宽的向量域选择访问。

```
// [bit+: width] : 从起始 bit 位开始递增，位宽为 width。
// 下面 2 种赋值是等效的
A = data1[31-: 8] ;
A = data1[31:24] ;

// [bit-: width] : 从起始 bit 位开始递减，位宽为 width。
// 下面 2 种赋值是等效的
B = data1[0+ : 8] ;
B = data1[0:7] ;
```

**4.数组**

在 Verilog 中允许声明 reg, wire 及其向量类型的数组，且数组的维度没有限制。

这里我们可以理解为数组就是更多的寄存器或者线网的组合，虽然在 Verilog 中对数组的维度和大小并没有严格的限制，但是我们在实际电路设计中还要考虑过多的器件是否会对电路的正常运行产生影响。

数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用，形如：<数组名>[<下标>]。对于多维数组来讲，用户需要说明其每一维的索引。例如：

```
integer          flag [7:0] ; //8个整数组成的数组
reg  [3:0]       counter [3:0] ; //由4个4bit计数器组成的数组
wire [7:0]       addr_bus [3:0] ; //由4个8bit wire型变量组成的数组
wire             data_bit[7:0][5:0] ; //声明1bit wire型变量的二维数组
reg [31:0]       data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组
```

```
flag [1]   = 32'd0 ; //将flag数组中第二个元素赋值为32bit的0值
counter[3] = 4'hF ;  //将数组counter中第4个元素的值赋值为4bit 十六进制数F，等效于counter[3][3:0] = 4'hF，即可省略宽度; 
assign addr_bus[0]        = 8'b0 ; //将数组addr_bus中第一个元素的值赋值为0
assign data_bit[0][1]     = 1'b1;  //将数组data_bit的第1行第2列的元素赋值为1，这里不能省略第二个访问标号，即 assign data_bit[0] = 1'b1; 是非法的。
data_4d[0][0][0][0][15:0] = 15'd3 ;  //将数组data_4d中标号为[0][0][0][0]的寄存器单元的15~0bit赋值为3
```

**5.参数**

参数用来表示常量，用关键字 parameter 声明，只能赋值一次。例如：

```
parameter      data_width = 10'd32 ;
parameter      i=1, j=2, k=3 ;
parameter      mem_size = data_width * 10 ;
```
我们在 Verilog 编程中，对于一些给定的数值，可以用parameter来替代，以增加代码的可读性。

**6.其他类型的寄存器**

在 Verilog 中，除了寄存器 (reg)，还有整数 (integer)，实数 (real)，时间 (time)等数据类型，但是其本质上也是不同位宽的寄存器。这里作简单介绍：

**整数**

整数用作电路模拟的情况较多，用于模拟不同情况的电平输入。
```
reg [1:0]      data1;
integer j ;  //整型变量，用来辅助生成数字电路
always@* begin
    for (j=0; j<=3;j=j+1) begin
            data1 <= j;
        end
end
```


**字符串**

在 Verilog 中，寄存器还可以存储字符串，字符串保存在 reg 类型的变量中，每个字符占用一个字节（8bit）。

字符串不能多行书写，即字符串中不能包含回车符。如果寄存器变量的宽度大于字符串的大小，则使用 0 来填充左边的空余位；如果寄存器变量的宽度小于字符串大小，则会截去字符串左边多余的数据。

```
reg [0: 14*8-1]       str ;
initial begin
    str = "run.runoob.com"; 
end
```

有一些特殊字符在显示字符串中有特殊意义，例如换行符，制表符等。如果需要在字符串中显示这些特殊的字符，则需要在前面加前缀转义字符 \ 。例如下表所示：

| 转义字符| 显示字符 |
|--|--|
|\n| 换行 |
|\t| 制表符 |
|%%| % |
| \ | \ |
| \ " | " |
| \ ooo| 1到3个8进制数字字符 |

**实数**

实数用途较少，仅简单举例。
```
real        data1 ;
initial begin
    data1 = 2e3 ;
    data1 = 3.75 ;
end
```

**时间**


Verilog 使用特殊的时间寄存器 time 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 $time 获取当前仿真时间。

```
time       current_time ;
initial begin
       #100 ;
       current_time = $time ; //current_time 的大小为 100
end
```

#### 运算符

我们这里仅介绍较为常用的运算符，有兴趣的同学可以在[这里](https://www.runoob.com/w3cnote/verilog-expression.html)来了解更多的运算符

常用的算数运算符包括乘（*）、除（/）、加（+）、减（-）、求幂（**）、取模（%）、正数（+）和负数（-）。
除了正负数为单目外，其余皆为双目运算符。

同时需要注意的是，在计算过程中，结果的位宽可能会扩展，因此需要十分注意结果的位宽是否足够，否则可能存在高位被丢弃的情况。
```
reg [3:0] add = 3'b111 + 3'b101;  两个三位的数相加，需要四位的寄存器来保存结果，避免高位被丢弃
reg [6:0] mul = 3'b111 * 4'b1000; 一个3位数与一个4位数相乘，需要3+4=7位的寄存器来保存结果。
```

同时在 Verilog 中，负数使用二进制补码来表示，不指定位宽来表示负数，编译器在转换时，会自动分配位宽，从而导致意想不到的结果。例如：
因此在编程过程中，我们可以直接赋值对应的补码来避免出现异常。

```
mula = -4'd4 ;
mulb = 2 ;
res = mula * mulb ;      //计算结果为res=-6'd8, 即res=6'h38，正常
res = mula * (-'d4) ;    //(4的32次幂-4) * 2, 结果异常
```

关系操作符与逻辑运算符也是我们在编程过程中常用于判断、选择，常用的关系运算符有大于（>）、小于（<）、大于等于（>=）、小于等于（<=）、逻辑相等（\=\=），逻辑不等（!=），全等（\=\==）和非全等（!==）。
常用的逻辑运算符有&&（逻辑与）, ||（逻辑或），!（逻辑非）。
除全等比较和部分逻辑运算符外，其他关系运算符如果两个操作数中有x或z（未知或高阻，将在下面数值表示中提到），则结果为x（未知）

```
A = 4 ;
B = 3 ;
X = 3'b1xx ;
   
A > B     // 为真
A <= B    // 为假
A >= Z    // 为X，不确定

--------------

A = 4 ;
B = 8'h04 ;
C = 4'bxxxx ;
D = 4'hx ;

A == B        // 为真
A == (B + 1)  // 为假
A == C        // 为X，不确定
A === C       // 为假，返回值为0
C === D       // 为真，返回值为1 因为可以按位比较都为x 所以为真

A = 3;
B = 0;
C = 2'b1x ;
   
---------------

A && B    //     为假
A || B    //     为真
! A       //     为假
! B       //     为真
A && C    //     为X，不确定
A || C    //     为真，因为A为真，无论C为什么都为真
(A==2) && (! B)  //为真，此时第一个操作数为表达式

```

此外还有按位运算符，按位操作符会对两个操作数按位操作，可以用作筛选、合并。
常用的按位运算符有取反（~），与（&），或（|），异或（^）。
除取反外，其余均为两目运算符，如果2个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。

```
A = 4'b0101 ;
B = 4'b1001 ;
C = 4'bx010 ;

// 如果将A当作被筛选数，B看作mask，A & B可以看作筛选保留A第一位和第四位的数，其余置0
A & B     //4' b0001 

// 可以看作A与B合并，如果简单的用运算符加可能会导致进位
A | B     //4' b1101

~A        //4' b1010
A ^ B     //4' b1100
A ~^ B    //4' b0011
B | C     //4' b1011
B & C     //4' bx000
```

拼接操作符与移位运算符可以帮助我们灵活的拼接组装我们需要用到的不同位的值。

移位运算符包括左移（<<），右移（>>），算术左移（<<<），算术右移（>>>），
拼接运算符用大括号 {，} 来表示，用于将多个操作数（向量）拼接成新的操作数（向量），信号间用逗号隔开。
算术左移和逻辑左移时，右边低位会补 0。

逻辑右移时，左边高位会补 0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。
```
A = 4'b1100 ;
B = 4'b0010 ;
A = A >> 2 ;        //结果为 4'b0011
A = A << 1;         //结果为 4'b1000
A = A <<< 1 ;       //结果为 4'b1000
C = B + (A>>>2);    //结果为 2 + (-4/4) = 1, 4'b0001
```

拼接运算符可以用作将不同的向量的部分连接起来，

```
A = 4'b1010 ;
B = 1'b1 ;
Y1 = {B, A[3:2], A[0], 4'h3 };  //结果为Y1='b1100_0011
Y2 = {4{B}, 3'd4};  //结果为 Y2=7'b111_1100
Y3 = {32{1'b0}};  //结果为 Y3=32h0，常用作寄存器初始化时匹配位宽的赋初值
```

条件运算符是三目运算符，一个完整的条件操作符使用相当于一个简易的 if 条件判断的使用，
由于其较为简单的表达形式和清晰的逻辑，我们在很多时候选择使用条件操作符来进行分支选择。

```
// 条件操作符的格式
condition_expression ? true_expression : false_expression

// 嵌套条件操作符的使用
assign   hsel = (addr[9:8] == 2'b00) ? hsel_p1 :
                (addr[9:8] == 2'b01) ? hsel_p2 :
                (addr[9:8] == 2'b10) ? hsel_p3 :
                (addr[9:8] == 2'b11) ? hsel_p4 ;
```

#### 宏定义

宏定义类似于 C 语言中的宏定义，在编译阶段就进行文本替换，可以增加代码的可读性或者简化一些重复操作定义，我们仅需要知道如何使用即可。

```
// 在代码中出现的DATA_DW将直接被转化为32
`define    DATA_DW     32
//用`S来代替系统函数$stop; (包括分号)
`define    S     $stop;   
//可以用`WORD_DEF来声明32bit寄存器变量
`define    WORD_DEF   reg [31:0]       
```

### 5.Verilog代码的赋值

在开始这部分之前，我们需要再强调一件事，Verilog HDL 是个一种硬件描述语言，最后都会转化为真实的电路器件。
因此在 Verilog 中赋值不同于 C 语言，存在连续赋值、过程赋值和过程连续赋值，其中过程赋值还分为阻塞赋值和非阻塞赋值。

#### 连续赋值

连续赋值语句是 Verilog 数据流建模的基本语句，用于对 wire 型变量进行赋值。

在 Verilog 中，我们用 assign 关键字来表示连续赋值，这里大家需要区分一件事，连续赋值只能赋值给 wire 型变量，但是 assign 关键字可以赋值给 reg 型变量，这是过程连续赋值。即 assign 不完全等同于连续赋值。

连续赋值的格式如下：

```
assign     LHS_target = RHS_expression  ；
```

LHS_target 只能是 wire 型变量，可以是标量或者向量。
RHS_expression 则没有要求，
只要 RHS_expression 表达式的操作数有事件发生（值的变化）时，RHS_expression 就会立刻重新计算，同时赋值给 LHS_target。

这里的连续赋值大家可以理解为，对于线网 LHS_target，它的输入端已经连接上了 RHS_expression 的一个综合器件。譬如我们举一个例子：

```
...
input [2:0] A,B;
...
wire [2:0] lhs;
assign lhs = A & B;
```

这里是不是就可以理解为，A 和 B 接入一个与门（按位与），然后输出端接入了一个名为 lhs 的线网，这样 lhs 线网的输出端的值，就为 A&B 的值，如果 A 或 B 的值有所变化，则lhs的输入也会相应变化。

如果这样理解之后，大家就不难理解为什么 wire 变量只能被连续赋值一次了，因为我们写完代码后，线路已经被焊死，我们无法通过电路本身的电平控制或者设计来重新连接电路，因此大家在实际实验中需要注意 wire 变量仅能连续赋值一次。

#### 过程赋值

与连续赋值相对应的就是过程赋值，过程性赋值是在 initial 或 always 语句块里的赋值，赋值对象是寄存器、整数、实数等类型。
这些变量在被赋值后，其值将保持不变，直到重新被赋予新值。

与连续性赋值不同，过程性赋值存在保持的特性，这其实也是电路中寄存器的特性。

与连续性赋值不同，过程赋值分为阻塞赋值和非阻塞赋值。

阻塞赋值属于顺序执行，即下一条语句执行前，当前语句一定会执行完毕。阻塞赋值语句使用等号 = 作为赋值符。

非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句的执行是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。
非阻塞赋值语句使用小于等于号 <= 作为赋值符。

我们在实际的操作中，不要混用阻塞赋值和非阻塞赋值，因为这样会导致时序不易控制，造成意向不到的后果。

在设计电路时，always 时序逻辑块中多用非阻塞赋值，always 组合逻辑块中多用阻塞赋值；在仿真电路时，initial 块中一般多用阻塞赋值。

我们下面再举一个经典的阻塞赋值引起的竞争冒险：

```
always @(posedge clk) begin
    a = b ;
end
 
always @(posedge clk) begin
    b = a;
end
```

可以看到，在这个电路中，当clk正沿的时候，a=b与b=a都需要运行，但是由于他们是阻塞赋值，因此谁先谁后很难分辨，造成竞争的局面。

但是如果改用非阻塞电路，2 个 always 块中语句并行执行，赋值操作右端操作数使用的是上一个时钟周期的旧值，此时 a<=b 与 b<=a 就可以相互不干扰的执行，达到交换寄存器值的目的。

```
always @(posedge clk) begin
    a <= b ;
end
 
always @(posedge clk) begin
    b <= a;
end
```

#### 过程连续赋值

过程连续赋值是过程赋值的一种。这种赋值语句能够替换其他所有 wire 或 reg 的赋值，改写了 wire 或 reg 型变量的当前值。

与过程赋值不同的是，过程连续赋值的表达式能被连续的驱动到 wire 或 reg 型变量中，即过程连续赋值发生作用时，右端表达式中任意操作数的变化都会引起过程连续赋值语句的重新执行。 

我们仅举一个简单的例子来介绍，同时注意，过程连续赋值可以放在 always 内或者其他地方，但是仍不允许多次赋值（在未取消赋值之前）。

```
module dff_assign(
    input       rstn,
    input       clk,
    input       D,
    output reg  Q
 );
 
    always @(posedge clk) begin
        Q <= D ;       //Q = D at posedge of clock
    end
 
    always @(negedge rstn) begin
        if(!rstn) begin
            assign Q = 1'b0 ; //change Q value when reset effective
        end
        else begin        //cancel the Q value overlay,
            deassign Q ;  //and Q remains 0-value until the coming of clock posedge
        end
    end
 
endmodule
```

### 6.模块与端口

Verilog HDL 是个一种硬件描述语言，那么一个 Verilog 文件就代表一个电路，我们之前讲过模块化的概念，所以我们可以认为我们在写一个电路的模块。

而在 Verilog 代码中，这一点表示的更具体，我们先来看一个完整的 Verilog 文件的基本格式。

```
module module_name 
#(parameter_list)
(port_list) ;
              Declarations_and_Statements ;
endmodule
```

大家可以看到，一个Verilog文件以module开头，以endmodule结尾，我们可以很容易的联想到，我们其实就是在写一个叫module_name的模块器件，确定了它的输入和输出端口后，补充内部逻辑，最后完成。大家可以参考在lab4作图完成的一个器件，如果你把其中的所有细节用一个方块代替，仅保留输入和输出端口，是不是也和一个Verilog代码相似。

![展示](img/lab6/4.jpg)

再思考在最开始的时候我们创建与门、或门等，如果将其中的线都隐藏，仅保留输入和输出，是不是也是一样的。

这其实就是我们硬件工程的基本逻辑，确定输入端口、输出端口，完成内部逻辑，最后封装为模块。

而在 Verilog 代码中，模块的命名和创建刚刚已经提到过了，内部逻辑的完成其实就是 Verilog 代码的其他部分，而输入与输出端口的定义我们下面给出例子：

```
module pad(
    // input端口不能声明为reg数据类型 因此可以省略
    input        DIN, OEN ,
    input [1:0]  PULL ,
    inout        PAD ,
    // output端口可以声明为reg或者wire两种数据类型
    output reg   DOUT,
    output wire  DWIRE
    );
 
endmodule
```

**模块例化**

在 Verilog 的模块化编程思路中，我们有提到将复杂的任务转化为多个简单的任务，再进行调用，这里我们简单介绍一下如何在完成了较为基础的模块后，在其他模块中调用该模块的功能。

这里其实大家很好理解，我们知道与门其实也是有内部结构的，但是在画电路图时我们仅仅需要调用整个与门，同时连接上相对应的端口即可应用，其实其他的模块也是这样。

我们之前提到了，每个 Verilog 文件其实就是一个模块，而且在定义模块的过程中，我们可以不定义输入与输出端口，但是必须要有模块的名字，这个模块名是为了其他模块调用其而准备的。

我们在 Vivado 中，在同一个项目中导入或增加了被调用模块，然后直接在其他模块中通过模块名调用即可，格式如下：

```
// 被调用模块，在pad.v文件中
module pad(
    // input端口不能声明为reg数据类型 因此可以省略
    input        DIN, OEN ,
    input [1:0]  PULL ,
    inout        PAD ,
    // output端口可以声明为reg或者wire两种数据类型
    output reg   DOUT,
    output wire  DWIRE
    );

// 顶层模块，在top.v文件中
...
// 模块名 命名该调用模块（可以随意取名，但不可与其他模块命名重复）
    pad   p1(
    // 该模块的端口名   与该端口相连的线网
        .DIN(           din),
    // 端口允许缺省，前提是输入并未用到
        .OEN(),
    // 端口允许直接赋值，等同接地或者接高电平
        .PULL(2'b10),
        
        .DOUT(dout),
        .DWIRE(dwire)
    );

// 可以多次调用同一模块
//     对该模块此次调用的命名不可以相同，不可以命名为p1
    pad p2(
        ...
    )
...

```

### 7.Verilog代码的过程结构

#### initial语句

initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。

如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句。

initial语句大多用于仿真时模拟输入电平，或者用于初始化器件的寄存器。

```
`timescale 1ns/1ns

module test ;
    reg  ai, bi ;
 
    initial begin
        bi         = 1 ;
        # 10;
        ai         = 1 ;
    end
 
endmodule
```

#### always语句

与 initial 语句相反，always 语句是重复执行的。always 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。

always 语句搭配事件控制符号@可以达到特定条件下执行特定事件的作用。

下面介绍几种常用的例子：

```
// 信号clk和rst只要发生变化，就执行q<=d，双边沿D触发器模型
always @(clk, rst) begin
    q <= d ;             
end   

// 在信号clk上升沿时刻，执行q<=d，正边沿D触发器模型
always @(posedge clk) begin 
    q <= d ;  
end

// 在信号clk下降沿时刻，执行q<=d，负边沿D触发器模型
always @(negedge clk) begin 
    q <= d ; 
end

// 任何信号只要发生变化，就执行q<=d，
always @(*) begin
    q <= d ;
end
```

### 8.Verilog代码的语句

我们刚刚介绍了两种过程结构和模块与端口的意义，下面我们要具体介绍模块内的逻辑的书写。

我们接下来介绍的条件语句、多路分支语句和循环语句，都需要在过程结构中，即都需要在 initial 语句或者 always 语句中。

```
// 正确写法
module test;
    reg a;
    always@(*) begin
        if(rst==1'b1) a<=1'b1;
    end
endmodule

// 错误写法
module test;
    reg a;
    if(rst==1'b1) a<=1'b1;
endmodule
```

虽然第二个看起来也很合理，我需要在rst为1的时候将给寄存器a赋值为1，但是大家考虑一下，我该在什么时候进行这个判断。你会发现想不到什么时候进行这个判断，只有在 always（对应的条件下）或者 initial（开始时）里，你才有这个对应的条件出现。

但是如果有同学一定要写在过程结构外面，那应该怎么做呢。我们考虑到在电路中，其实有一个隐藏的实时更新的条件，线网。对于一个线网来说，输入端改变将马上引起输出端的改变，因此我们可以用连续赋值或者过程连续赋值来实现这一点。

譬如我需要实现寄存器 a 在 rst 为 1 时，且寄存器 b 的值也为 1 时，值为 0，否则为 1，我可以这样写。

```
assign a = (b & rst) ? 1'b0 : 1'b1;
```

下面我们来介绍三种常用的语句

#### 条件语句

通过判断条件来进行不同分支的操作，条件表达必须在圆括号之内，格式和例子如下：

```
if (condition1)       true_statement1 ;
else if (condition2)        true_statement2 ;
else if (condition3)        true_statement3 ;
else                      default_statement ;

module test;
...
    always @(*) begin
        if (sel == 2'b00)
            sout_t = p0 ;
        else if (sel == 2'b01)
            sout_t = p1 ;
        else if (sel == 2'b10)
            sout_t = p2 ;
        else
            sout_t = p3 ;
    end
...
endmodule
```

#### 多路分支语句

case 语句是一种多路条件分支的形式，可以解决 if 语句中有多个条件选项时使用不方便的问题，格式和例子如下。

```
case(case_expr)
    condition1     :             true_statement1 ;
    condition2     :             true_statement2 ;
    ……
    default        :             default_statement ;
endcase

module mux4to1;
...
    always @(*) begin
        case(sel)
            2'b00:   begin       
                    sout_t = p0 ;
                end
            2'b01:       sout_t = p1 ;
            2'b10:       sout_t = p2 ;
            default:     sout_t = p3 ;
        endcase
    end
...
endmodule
```

#### 循环语句

我们仅介绍 for 循环语句，一般在仿真时用于遍历，格式和例子如下：

```
for(initial_assignment; condition ; step_assignment)  begin
    …
end

module test;
...
    initial begin
        counter2 = 'b0 ;
        for (i=0; i<=10; i=i+1) begin
            #10 ;
            counter2 = counter2 + 1'b1 ;
        end
    end
endmodule
```